import java.util.Arrays;
import java.util.Objects;

/**
 *  Как вычисляются hash функция [#1007]
 *
 *  1. В это задаче нужно рассказать - как правильно вычислять hashCode у объекта.
 *  3.10. Рассказать и продемонстрировать как переопределяют метод hashCode.
 описано в effective java.
 */
public class Example {
    private int id;
    /**
     * вот так вычислается хэш код у обьекта.елси у него одно поле
     * если полей множество,то вычисляется result для каждого значимого в обьекте поля ,
     * потом они складываются
     *
     Все объекты в java наследуют стандартную реализацию hashCode() функции,
     описанной в классе Object. Эта функция возвращает хеш-код полученный путем
     конвертации внутреннего адреса объекта в число, что ведет к созданию
     уникального кода для каждого отдельного объекта.
     * @return
     */
    @Override
    public int hashCode() {
        int result = 1;
            result = 31 * result + id; //Выражение result * 31 эквивалентно (result << 5) - result.
        return result;
    }

    /**
     * 1.
     *
     Присвойте переменной result (тип int) некоторое ненулевое число, скажем, 17.
     2. Для каждого значимого поля f в вашем объекте (т. е. поля, значение которого принимается в
     расчет методом equals), выполните следующее:
     а. Вычислите для поля хэш-код с (тип int):а
     1. Если поле имеет тип boolean, вычислите (f ? О : 1).
     2. Если поле имеет тип byte, char, short или int, вычислите (int)f.
     3. Если поле имеет тип long, вычислите (int)(f - (f > > > 32)).
     4. Если поле имеет тип float, вычислите Float. floatтoIntBits(f).
     5. Если - тип double, вычислите Double. doubleToLongBits(f), а затем
     преобразуйте полученное значение, как указано в п. 2.a.3.
     37
     6. Если поле является ссылкой на объект, а метод equals
     данного класса сравнивает это поле, рекурсивно вызывая другие методы equals,
     так же рекурсивно вызывайте для этого поля метод hashCode. Если требуется
     более сложное сравнение, вычислите для данного поля каноническое
     представление (canonical representation), а затем вызовите для него
     метод hashCode. Если значение поля равно null, возвращайте О (можно любую
     другую константу, но традиционно используется О ).
     7. Если поле является массивом, обрабатываете его так, как если бы каждый
     его элемент был отдельным полем. Иными словами, вычислите хэш-код для
     каждого значимого элемента, рекурсивно применяя данные правила, а затем
     объедините полученные значения так, как описано в п. 2.Ь.
     b. Объедините хэш-код с, вычисленный на этапе а, с текущим значением поля resul t
     следующим образом:
     result = 37*result + с;
     3. Верните значение resul .
     */
    /**
     * хэш код для обьекта. с множеством полей Objects.hash(name, children, birthday)
     */
    public static int hash(Object... values) {
        return Arrays.hashCode(values);
    }

    /**
     * для  Arrays.hashCode
     * @param a
     * @return
     */
    public static int hashCode(Object a[]) {
        if (a == null)
            return 0;

        int result = 1;

        for (Object element : a)
            result = 31 * result + (element == null ? 0 : element.hashCode());

        return result;
    }
}
